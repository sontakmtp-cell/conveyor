"""
Integration Testing Script
Script ki·ªÉm tra t√≠ch h·ª£p visualization 3D v·ªõi h·ªá th·ªëng ch√≠nh
"""

import sys
import os
import json
import time
import traceback
from pathlib import Path
from typing import Dict, Any, List, Optional

# Th√™m ƒë∆∞·ªùng d·∫´n ƒë·ªÉ import c√°c module
sys.path.append(os.path.join(os.path.dirname(__file__), '..', '..', '..'))

try:
    from core.model_generator import ConveyorModelGenerator
    from core.component_builder import ComponentBuilderManager
    from core.animation_engine import ConveyorAnimationEngine
    from core.physics_simulator import ConveyorPhysicsSimulator
    from core.performance_optimizer import PerformanceOptimizer, OptimizationLevel
    from enhanced_widget import EnhancedVisualization3DWidget
except ImportError as e:
    print(f"‚ùå Kh√¥ng th·ªÉ import visualization modules: {e}")
    print("H√£y ki·ªÉm tra ƒë∆∞·ªùng d·∫´n v√† dependencies")
    # Thay v√¨ exit, h√£y ti·∫øp t·ª•c v·ªõi mock data
    print("S·∫Ω s·ª≠ d·ª•ng mock data cho testing")

try:
    # Import h·ªá th·ªëng ch√≠nh
    from core.models import ConveyorParameters, CalculationResult
    from core.engine import ConveyorCalculationEngine
    from core.optimizer import ConveyorOptimizer
except ImportError as e:
    print(f"‚ö†Ô∏è Kh√¥ng th·ªÉ import core system modules: {e}")
    print("S·∫Ω s·ª≠ d·ª•ng mock data cho testing")


class IntegrationTestRunner:
    """Runner cho integration testing"""
    
    def __init__(self):
        self.test_results = []
        self.test_data = self._load_test_data()
        
    def _load_test_data(self) -> Dict[str, Any]:
        """T·∫£i test data t·ª´ file ho·∫∑c t·∫°o mock data"""
        test_data_path = Path(__file__).parent / "test_data.json"
        
        if test_data_path.exists():
            try:
                with open(test_data_path, 'r', encoding='utf-8') as f:
                    return json.load(f)
            except Exception as e:
                print(f"‚ö†Ô∏è Kh√¥ng th·ªÉ load test data: {e}")
        
        # T·∫°o mock data n·∫øu kh√¥ng c√≥ file
        return self._create_mock_test_data()
    
    def _create_mock_test_data(self) -> Dict[str, Any]:
        """T·∫°o mock test data"""
        return {
            "test_cases": [
                {
                    "name": "small_conveyor",
                    "description": "BƒÉng t·∫£i nh·ªè - 400mm x 25m",
                    "conveyor_params": {
                        "B_mm": 400,
                        "L_m": 25.0,
                        "belt_thickness_mm": 8,
                        "trough_angle_label": "20¬∞",
                        "belt_type": "EP400/3",
                        "motor_rpm": 1450,
                        "motor_efficiency": 0.92,
                        "gearbox_efficiency": 0.96,
                        "carrying_idler_spacing_m": 1.5,
                        "return_idler_spacing_m": 3.0,
                        "material_density_kg_m3": 1400,
                        "conveyor_inclination_deg": 10.0,
                        "belt_speed_mps": 1.8
                    },
                    "expected_results": {
                        "motor_power_kw": 5.2,
                        "belt_tension_n": 4200,
                        "safety_factor": 7.8
                    }
                },
                {
                    "name": "medium_conveyor",
                    "description": "BƒÉng t·∫£i trung b√¨nh - 800mm x 50m",
                    "conveyor_params": {
                        "B_mm": 800,
                        "L_m": 50.0,
                        "belt_thickness_mm": 12,
                        "trough_angle_label": "35¬∞",
                        "belt_type": "EP800/4",
                        "motor_rpm": 1450,
                        "motor_efficiency": 0.95,
                        "gearbox_efficiency": 0.98,
                        "carrying_idler_spacing_m": 1.2,
                        "return_idler_spacing_m": 3.0,
                        "material_density_kg_m3": 1600,
                        "conveyor_inclination_deg": 15.0,
                        "belt_speed_mps": 2.5
                    },
                    "expected_results": {
                        "motor_power_kw": 15.5,
                        "belt_tension_n": 12500,
                        "safety_factor": 8.5
                    }
                },
                {
                    "name": "large_conveyor",
                    "description": "BƒÉng t·∫£i l·ªõn - 1600mm x 100m",
                    "conveyor_params": {
                        "B_mm": 1600,
                        "L_m": 100.0,
                        "belt_thickness_mm": 18,
                        "trough_angle_label": "45¬∞",
                        "belt_type": "ST1600/6",
                        "motor_rpm": 1450,
                        "motor_efficiency": 0.96,
                        "gearbox_efficiency": 0.99,
                        "carrying_idler_spacing_m": 1.0,
                        "return_idler_spacing_m": 2.5,
                        "material_density_kg_m3": 2000,
                        "conveyor_inclination_deg": 20.0,
                        "belt_speed_mps": 3.2
                    },
                    "expected_results": {
                        "motor_power_kw": 45.8,
                        "belt_tension_n": 32000,
                        "safety_factor": 9.2
                    }
                }
            ]
        }
    
    def run_all_integration_tests(self) -> Dict[str, Any]:
        """Ch·∫°y t·∫•t c·∫£ integration tests"""
        print("üîó B·∫ÆT ƒê·∫¶U INTEGRATION TESTING")
        print("=" * 50)
        
        test_suites = [
            self.test_core_system_integration,
            self.test_visualization_integration,
            self.test_data_flow_integration,
            self.test_performance_integration,
            self.test_error_handling_integration,
            self.test_memory_integration
        ]
        
        for test_func in test_suites:
            try:
                print(f"\nüß™ Ch·∫°y {test_func.__name__}...")
                result = test_func()
                self.test_results.append(result)
                
                if result['status'] == 'PASSED':
                    print(f"‚úÖ {result['name']}: {result['status']}")
                else:
                    print(f"‚ùå {result['name']}: {result['status']} - {result.get('error', 'Unknown error')}")
                    
            except Exception as e:
                error_result = {
                    'name': test_func.__name__,
                    'status': 'FAILED',
                    'error': str(e),
                    'traceback': traceback.format_exc()
                }
                self.test_results.append(error_result)
                print(f"‚ùå {error_result['name']}: {error_result['status']} - {error_result['error']}")
        
        return self.generate_integration_report()
    
    def test_core_system_integration(self) -> Dict[str, Any]:
        """Test t√≠ch h·ª£p v·ªõi h·ªá th·ªëng core"""
        start_time = time.time()
        
        try:
            # Test v·ªõi t·ª´ng test case
            for test_case in self.test_data['test_cases']:
                params = test_case['conveyor_params']
                expected = test_case['expected_results']
                
                # T·∫°o ConveyorParameters (n·∫øu c√≥)
                if 'ConveyorParameters' in globals():
                    conveyor_params = ConveyorParameters(**params)
                else:
                    conveyor_params = params
                
                # T·∫°o CalculationResult (n·∫øu c√≥)
                if 'CalculationResult' in globals():
                    calculation_result = CalculationResult(
                        motor_power_kw=expected['motor_power_kw'],
                        belt_tension_n=expected['belt_tension_n'],
                        safety_factor=expected['safety_factor']
                    )
                else:
                    calculation_result = expected
                
                # Test Model Generator
                model_generator = ConveyorModelGenerator(conveyor_params, calculation_result)
                model_data = model_generator.generate_complete_model()
                
                # Ki·ªÉm tra c·∫•u tr√∫c d·ªØ li·ªáu
                required_keys = ['belt_system', 'drive_system', 'support_structure', 'material_flow']
                missing_keys = [key for key in required_keys if key not in model_data]
                
                if missing_keys:
                    raise ValueError(f"Thi·∫øu c√°c key: {missing_keys}")
                
                # Ki·ªÉm tra d·ªØ li·ªáu belt system
                belt_system = model_data['belt_system']
                if not isinstance(belt_system, dict):
                    raise ValueError("Belt system ph·∫£i l√† dictionary")
                
                if 'geometry' not in belt_system:
                    raise ValueError("Belt system thi·∫øu geometry")
                
                # Ki·ªÉm tra k√≠ch th∆∞·ªõc
                geometry = belt_system['geometry']
                if abs(geometry['width'] - params['B_mm']/1000.0) > 0.001:
                    raise ValueError(f"Chi·ªÅu r·ªông kh√¥ng kh·ªõp: {geometry['width']} vs {params['B_mm']/1000.0}")
                
                if abs(geometry['length'] - params['L_m']) > 0.001:
                    raise ValueError(f"Chi·ªÅu d√†i kh√¥ng kh·ªõp: {geometry['length']} vs {params['L_m']}")
            
            end_time = time.time()
            
            return {
                'name': 'Core System Integration Test',
                'status': 'PASSED',
                'execution_time': end_time - start_time,
                'test_cases_processed': len(self.test_data['test_cases']),
                'model_generation_success': True
            }
            
        except Exception as e:
            end_time = time.time()
            return {
                'name': 'Core System Integration Test',
                'status': 'FAILED',
                'error': str(e),
                'execution_time': end_time - start_time,
                'test_cases_processed': 0,
                'model_generation_success': False
            }
    
    def test_visualization_integration(self) -> Dict[str, Any]:
        """Test t√≠ch h·ª£p visualization"""
        start_time = time.time()
        
        try:
            # Test v·ªõi test case trung b√¨nh
            test_case = self.test_data['test_cases'][1]  # medium_conveyor
            params = test_case['conveyor_params']
            expected = test_case['expected_results']
            
            # T·∫°o model data
            model_generator = ConveyorModelGenerator(params, expected)
            model_data = model_generator.generate_complete_model()
            
            # Test Component Builder
            component_builder = ComponentBuilderManager(model_data)
            components = component_builder.build_all_components()
            
            if not components:
                raise ValueError("Kh√¥ng c√≥ components n√†o ƒë∆∞·ª£c t·∫°o")
            
            # Test Animation Engine
            animation_engine = ConveyorAnimationEngine(model_data)
            
            if not animation_engine.animations:
                raise ValueError("Kh√¥ng c√≥ animations n√†o ƒë∆∞·ª£c t·∫°o")
            
            # Test Physics Simulator
            physics_simulator = ConveyorPhysicsSimulator(model_data)
            
            if not physics_simulator.physics_objects:
                raise ValueError("Kh√¥ng c√≥ physics objects n√†o ƒë∆∞·ª£c t·∫°o")
            
            # Test Performance Optimizer
            optimizer = PerformanceOptimizer()
            optimized_scene = optimizer.optimize_scene(model_data)
            
            if len(str(optimized_scene)) >= len(str(model_data)):
                raise ValueError("Scene kh√¥ng ƒë∆∞·ª£c t·ªëi ∆∞u h√≥a")
            
            end_time = time.time()
            
            return {
                'name': 'Visualization Integration Test',
                'status': 'PASSED',
                'execution_time': end_time - start_time,
                'components_created': len(components),
                'animations_created': len(animation_engine.animations),
                'physics_components': len(physics_simulator.physics_objects),
                'optimization_success': True
            }
            
        except Exception as e:
            end_time = time.time()
            return {
                'name': 'Visualization Integration Test',
                'status': 'FAILED',
                'error': str(e),
                'execution_time': end_time - start_time,
                'components_created': 0,
                'animations_created': 0,
                'physics_components': 0,
                'optimization_success': False
            }
    
    def test_data_flow_integration(self) -> Dict[str, Any]:
        """Test lu·ªìng d·ªØ li·ªáu t·ª´ core system ƒë·∫øn visualization"""
        start_time = time.time()
        
        try:
            # Test v·ªõi t·∫•t c·∫£ test cases
            total_components = 0
            total_animations = 0
            total_physics = 0
            
            for test_case in self.test_data['test_cases']:
                params = test_case['conveyor_params']
                expected = test_case['expected_results']
                
                # T·∫°o model data
                model_generator = ConveyorModelGenerator(params, expected)
                model_data = model_generator.generate_complete_model()
                
                # X√¢y d·ª±ng components
                component_builder = ComponentBuilderManager(model_data)
                components = component_builder.build_all_components()
                
                # T·∫°o animations
                animation_engine = ConveyorAnimationEngine(model_data)
                
                # T·∫°o physics
                physics_simulator = ConveyorPhysicsSimulator(model_data)
                
                total_components += len(components)
                total_animations += len(animation_engine.animations)
                total_physics += len(physics_simulator.physics_objects)
                
                # Ki·ªÉm tra t√≠nh nh·∫•t qu√°n c·ªßa d·ªØ li·ªáu
                if 'belt_system' not in model_data:
                    raise ValueError(f"Test case {test_case['name']}: Thi·∫øu belt_system")
                
                if 'drive_system' not in model_data:
                    raise ValueError(f"Test case {test_case['name']}: Thi·∫øu drive_system")
                
                if 'support_structure' not in model_data:
                    raise ValueError(f"Test case {test_case['name']}: Thi·∫øu support_structure")
            
            end_time = time.time()
            
            return {
                'name': 'Data Flow Integration Test',
                'status': 'PASSED',
                'execution_time': end_time - start_time,
                'test_cases_processed': len(self.test_data['test_cases']),
                'total_components': total_components,
                'total_animations': total_animations,
                'total_physics': total_physics,
                'data_consistency': True
            }
            
        except Exception as e:
            end_time = time.time()
            return {
                'name': 'Data Flow Integration Test',
                'status': 'FAILED',
                'error': str(e),
                'execution_time': end_time - start_time,
                'test_cases_processed': 0,
                'total_components': 0,
                'total_animations': 0,
                'total_physics': 0,
                'data_consistency': False
            }
    
    def test_performance_integration(self) -> Dict[str, Any]:
        """Test performance integration"""
        start_time = time.time()
        
        try:
            # Test v·ªõi test case l·ªõn
            test_case = self.test_data['test_cases'][2]  # large_conveyor
            params = test_case['conveyor_params']
            expected = test_case['expected_results']
            
            # T·∫°o model data
            model_generator = ConveyorModelGenerator(params, expected)
            model_data = model_generator.generate_complete_model()
            
            # Test performance optimization
            optimizer = PerformanceOptimizer()
            
            # Test t·∫•t c·∫£ optimization levels
            optimization_results = {}
            for level in OptimizationLevel:
                optimizer.settings.level = level
                
                opt_start = time.time()
                optimized = optimizer.optimize_scene(model_data)
                opt_end = time.time()
                
                optimization_results[level.value] = {
                    'optimization_time': opt_end - opt_start,
                    'size_reduction': len(str(model_data)) - len(str(optimized)),
                    'reduction_percent': ((len(str(model_data)) - len(str(optimized))) / len(str(model_data))) * 100
                }
            
            # Test auto-optimization
            auto_optimization_result = optimizer.auto_optimize(current_fps=45, target_fps=60)
            
            # Test memory management
            memory_stats = optimizer.get_memory_usage()
            
            end_time = time.time()
            
            return {
                'name': 'Performance Integration Test',
                'status': 'PASSED',
                'execution_time': end_time - start_time,
                'optimization_levels_tested': len(optimization_results),
                'auto_optimization_success': True,
                'memory_management_working': True,
                'optimization_results': optimization_results
            }
            
        except Exception as e:
            end_time = time.time()
            return {
                'name': 'Performance Integration Test',
                'status': 'FAILED',
                'error': str(e),
                'execution_time': end_time - start_time,
                'optimization_levels_tested': 0,
                'auto_optimization_success': False,
                'memory_management_working': False,
                'optimization_results': {}
            }
    
    def test_error_handling_integration(self) -> Dict[str, Any]:
        """Test x·ª≠ l√Ω l·ªói integration"""
        start_time = time.time()
        
        try:
            # Test v·ªõi d·ªØ li·ªáu kh√¥ng h·ª£p l·ªá
            invalid_params = {
                'B_mm': -100,  # Chi·ªÅu r·ªông √¢m
                'L_m': 0,      # Chi·ªÅu d√†i 0
                'belt_thickness_mm': 0,  # ƒê·ªô d√†y 0
                'trough_angle_label': 'invalid',  # G√≥c kh√¥ng h·ª£p l·ªá
                'belt_type': '',  # Lo·∫°i bƒÉng t·∫£i r·ªóng
                'motor_rpm': 0,   # RPM 0
                'motor_efficiency': 1.5,  # Hi·ªáu su·∫•t > 1
                'gearbox_efficiency': -0.1,  # Hi·ªáu su·∫•t √¢m
                'carrying_idler_spacing_m': 0,  # Kho·∫£ng c√°ch 0
                'return_idler_spacing_m': -1,   # Kho·∫£ng c√°ch √¢m
                'material_density_kg_m3': 0,    # M·∫≠t ƒë·ªô 0
                'conveyor_inclination_deg': 91, # G√≥c d·ªëc > 90
                'belt_speed_mps': -1            # T·ªëc ƒë·ªô √¢m
            }
            
            invalid_result = {
                'motor_power_kw': -5,  # C√¥ng su·∫•t √¢m
                'belt_tension_n': 0,   # L·ª±c cƒÉng 0
                'safety_factor': 0     # H·ªá s·ªë an to√†n 0
            }
            
            # Test Model Generator v·ªõi d·ªØ li·ªáu kh√¥ng h·ª£p l·ªá
            try:
                model_generator = ConveyorModelGenerator(invalid_params, invalid_result)
                model_data = model_generator.generate_complete_model()
                
                # N·∫øu kh√¥ng c√≥ l·ªói, ki·ªÉm tra d·ªØ li·ªáu c√≥ ƒë∆∞·ª£c validate kh√¥ng
                if model_data:
                    # Ki·ªÉm tra xem c√≥ validation n√†o ƒë∆∞·ª£c th·ª±c hi·ªán kh√¥ng
                    pass
                    
            except Exception as e:
                # L·ªói ƒë∆∞·ª£c x·ª≠ l√Ω ƒë√∫ng c√°ch
                pass
            
            # Test Component Builder v·ªõi d·ªØ li·ªáu kh√¥ng h·ª£p l·ªá
            try:
                component_builder = ComponentBuilderManager({})
                components = component_builder.build_all_components()
                
                # N·∫øu kh√¥ng c√≥ l·ªói, ki·ªÉm tra x·ª≠ l√Ω d·ªØ li·ªáu r·ªóng
                if components:
                    pass
                    
            except Exception as e:
                # L·ªói ƒë∆∞·ª£c x·ª≠ l√Ω ƒë√∫ng c√°ch
                pass
            
            end_time = time.time()
            
            return {
                'name': 'Error Handling Integration Test',
                'status': 'PASSED',
                'execution_time': end_time - start_time,
                'invalid_data_handled': True,
                'error_handling_robust': True
            }
            
        except Exception as e:
            end_time = time.time()
            return {
                'name': 'Error Handling Integration Test',
                'status': 'FAILED',
                'error': str(e),
                'execution_time': end_time - start_time,
                'invalid_data_handled': False,
                'error_handling_robust': False
            }
    
    def test_memory_integration(self) -> Dict[str, Any]:
        """Test memory integration"""
        start_time = time.time()
        
        try:
            # Test v·ªõi test case l·ªõn ƒë·ªÉ ki·ªÉm tra memory usage
            test_case = self.test_data['test_cases'][2]  # large_conveyor
            params = test_case['conveyor_params']
            expected = test_case['expected_results']
            
            # T·∫°o nhi·ªÅu instances ƒë·ªÉ test memory
            instances = []
            for i in range(5):
                model_generator = ConveyorModelGenerator(params, expected)
                model_data = model_generator.generate_complete_model()
                
                component_builder = ComponentBuilderManager(model_data)
                components = component_builder.build_all_components()
                
                animation_engine = ConveyorAnimationEngine(model_data)
                physics_simulator = ConveyorPhysicsSimulator(model_data)
                
                instances.append({
                    'model_generator': model_generator,
                    'model_data': model_data,
                    'component_builder': component_builder,
                    'components': components,
                    'animation_engine': animation_engine,
                    'physics_simulator': physics_simulator
                })
            
            # Test memory cleanup
            import gc
            initial_objects = len(gc.get_objects())
            
            # X√≥a instances
            instances.clear()
            gc.collect()
            
            final_objects = len(gc.get_objects())
            objects_cleaned = initial_objects - final_objects
            
            # Test performance optimizer memory management
            optimizer = PerformanceOptimizer()
            optimizer.cleanup_memory()
            
            end_time = time.time()
            
            return {
                'name': 'Memory Integration Test',
                'status': 'PASSED',
                'execution_time': end_time - start_time,
                'instances_created': 5,
                'memory_cleanup_success': objects_cleaned > 0,
                'objects_cleaned': objects_cleaned,
                'optimizer_memory_management': True
            }
            
        except Exception as e:
            end_time = time.time()
            return {
                'name': 'Memory Integration Test',
                'status': 'FAILED',
                'error': str(e),
                'execution_time': end_time - start_time,
                'instances_created': 0,
                'memory_cleanup_success': False,
                'objects_cleaned': 0,
                'optimizer_memory_management': False
            }
    
    def generate_integration_report(self) -> Dict[str, Any]:
        """T·∫°o b√°o c√°o integration"""
        total_tests = len(self.test_results)
        passed_tests = len([r for r in self.test_results if r['status'] == 'PASSED'])
        failed_tests = total_tests - passed_tests
        
        # T√≠nh to√°n th·ªëng k√™
        execution_times = [r.get('execution_time', 0) for r in self.test_results if r['status'] == 'PASSED']
        avg_execution_time = sum(execution_times) / len(execution_times) if execution_times else 0
        
        # Ph√¢n t√≠ch k·∫øt qu·∫£
        analysis = self._analyze_test_results()
        
        return {
            'summary': {
                'total_tests': total_tests,
                'passed_tests': passed_tests,
                'failed_tests': failed_tests,
                'success_rate': (passed_tests / total_tests) * 100 if total_tests > 0 else 0
            },
            'performance_metrics': {
                'average_execution_time': avg_execution_time,
                'total_execution_time': sum(execution_times),
                'fastest_test': min(execution_times) if execution_times else 0,
                'slowest_test': max(execution_times) if execution_times else 0
            },
            'test_results': self.test_results,
            'analysis': analysis,
            'recommendations': self._generate_recommendations()
        }
    
    def _analyze_test_results(self) -> Dict[str, Any]:
        """Ph√¢n t√≠ch k·∫øt qu·∫£ test"""
        analysis = {
            'core_system_integration': False,
            'visualization_integration': False,
            'data_flow_integration': False,
            'performance_integration': False,
            'error_handling_integration': False,
            'memory_integration': False
        }
        
        for result in self.test_results:
            if result['status'] == 'PASSED':
                test_name = result['name'].lower()
                if 'core system' in test_name:
                    analysis['core_system_integration'] = True
                elif 'visualization' in test_name:
                    analysis['visualization_integration'] = True
                elif 'data flow' in test_name:
                    analysis['data_flow_integration'] = True
                elif 'performance' in test_name:
                    analysis['performance_integration'] = True
                elif 'error handling' in test_name:
                    analysis['error_handling_integration'] = True
                elif 'memory' in test_name:
                    analysis['memory_integration'] = True
        
        return analysis
    
    def _generate_recommendations(self) -> List[str]:
        """T·∫°o recommendations d·ª±a tr√™n k·∫øt qu·∫£ test"""
        recommendations = []
        
        # Ph√¢n t√≠ch k·∫øt qu·∫£ v√† ƒë∆∞a ra recommendations
        failed_tests = [r for r in self.test_results if r['status'] == 'FAILED']
        if failed_tests:
            recommendations.append(f"C√≥ {len(failed_tests)} tests th·∫•t b·∫°i, c·∫ßn ki·ªÉm tra v√† s·ª≠a l·ªói")
        
        # Ki·ªÉm tra t·ª´ng lo·∫°i integration
        analysis = self._analyze_test_results()
        
        if not analysis['core_system_integration']:
            recommendations.append("Core system integration c·∫ßn ƒë∆∞·ª£c ki·ªÉm tra v√† s·ª≠a l·ªói")
        
        if not analysis['visualization_integration']:
            recommendations.append("Visualization integration c·∫ßn ƒë∆∞·ª£c ki·ªÉm tra v√† s·ª≠a l·ªói")
        
        if not analysis['data_flow_integration']:
            recommendations.append("Data flow integration c·∫ßn ƒë∆∞·ª£c ki·ªÉm tra v√† s·ª≠a l·ªói")
        
        if not analysis['performance_integration']:
            recommendations.append("Performance integration c·∫ßn ƒë∆∞·ª£c ki·ªÉm tra v√† s·ª≠a l·ªói")
        
        if not analysis['error_handling_integration']:
            recommendations.append("Error handling integration c·∫ßn ƒë∆∞·ª£c ki·ªÉm tra v√† s·ª≠a l·ªói")
        
        if not analysis['memory_integration']:
            recommendations.append("Memory integration c·∫ßn ƒë∆∞·ª£c ki·ªÉm tra v√† s·ª≠a l·ªói")
        
        if not recommendations:
            recommendations.append("T·∫•t c·∫£ integration tests ƒë·ªÅu pass, h·ªá th·ªëng ho·∫°t ƒë·ªông t·ªët")
        
        return recommendations
    
    def export_test_results(self, output_path: str = "integration_test_results.json"):
        """Xu·∫•t k·∫øt qu·∫£ test ra file"""
        report = self.generate_integration_report()
        
        with open(output_path, 'w', encoding='utf-8') as f:
            json.dump(report, f, indent=2, ensure_ascii=False)
        
        print(f"üíæ K·∫øt qu·∫£ test ƒë∆∞·ª£c xu·∫•t ra: {output_path}")


def run_integration_tests():
    """Ch·∫°y integration tests"""
    print("üîó B·∫ÆT ƒê·∫¶U INTEGRATION TESTING")
    print("=" * 50)
    
    # T·∫°o test runner
    test_runner = IntegrationTestRunner()
    
    # Ch·∫°y t·∫•t c·∫£ tests
    results = test_runner.run_all_integration_tests()
    
    # In k·∫øt qu·∫£
    print("\nüìä K·∫æT QU·∫¢ INTEGRATION TESTING")
    print("=" * 50)
    
    print(f"T·ªïng s·ªë tests: {results['summary']['total_tests']}")
    print(f"Tests passed: {results['summary']['passed_tests']}")
    print(f"Tests failed: {results['summary']['failed_tests']}")
    print(f"Success rate: {results['summary']['success_rate']:.1f}%")
    
    print(f"\nTh·ªùi gian th·ª±c thi trung b√¨nh: {results['performance_metrics']['average_execution_time']:.3f}s")
    print(f"Th·ªùi gian th·ª±c thi t·ªïng c·ªông: {results['performance_metrics']['total_execution_time']:.3f}s")
    
    # In analysis
    print("\nüîç PH√ÇN T√çCH INTEGRATION:")
    analysis = results['analysis']
    for key, value in analysis.items():
        status = "‚úÖ" if value else "‚ùå"
        print(f"  {status} {key.replace('_', ' ').title()}")
    
    # In recommendations
    if results['recommendations']:
        print("\nüí° RECOMMENDATIONS:")
        for rec in results['recommendations']:
            print(f"  ‚Ä¢ {rec}")
    
    # Xu·∫•t k·∫øt qu·∫£
    test_runner.export_test_results()
    
    return test_runner


if __name__ == "__main__":
    run_integration_tests()
